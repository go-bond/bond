// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/go-bond/bond (interfaces: Filter,FilterStorer,TableScanner,Batch)
//
// Generated by this command:
//
//	mockgen -destination ./testing/mocks/bond/bond.go -package bondmock github.com/go-bond/bond Filter,FilterStorer,TableScanner,Batch
//

// Package bondmock is a generated GoMock package.
package bondmock

import (
	context "context"
	io "io"
	reflect "reflect"

	bond "github.com/go-bond/bond"
	gomock "go.uber.org/mock/gomock"
)

// MockFilter is a mock of Filter interface.
type MockFilter struct {
	ctrl     *gomock.Controller
	recorder *MockFilterMockRecorder
	isgomock struct{}
}

// MockFilterMockRecorder is the mock recorder for MockFilter.
type MockFilterMockRecorder struct {
	mock *MockFilter
}

// NewMockFilter creates a new mock instance.
func NewMockFilter(ctrl *gomock.Controller) *MockFilter {
	mock := &MockFilter{ctrl: ctrl}
	mock.recorder = &MockFilterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFilter) EXPECT() *MockFilterMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockFilter) Add(ctx context.Context, key []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Add", ctx, key)
}

// Add indicates an expected call of Add.
func (mr *MockFilterMockRecorder) Add(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockFilter)(nil).Add), ctx, key)
}

// Clear mocks base method.
func (m *MockFilter) Clear(ctx context.Context, store bond.FilterStorer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Clear", ctx, store)
	ret0, _ := ret[0].(error)
	return ret0
}

// Clear indicates an expected call of Clear.
func (mr *MockFilterMockRecorder) Clear(ctx, store any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Clear", reflect.TypeOf((*MockFilter)(nil).Clear), ctx, store)
}

// Load mocks base method.
func (m *MockFilter) Load(ctx context.Context, store bond.FilterStorer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Load", ctx, store)
	ret0, _ := ret[0].(error)
	return ret0
}

// Load indicates an expected call of Load.
func (mr *MockFilterMockRecorder) Load(ctx, store any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Load", reflect.TypeOf((*MockFilter)(nil).Load), ctx, store)
}

// MayContain mocks base method.
func (m *MockFilter) MayContain(ctx context.Context, key []byte) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MayContain", ctx, key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// MayContain indicates an expected call of MayContain.
func (mr *MockFilterMockRecorder) MayContain(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MayContain", reflect.TypeOf((*MockFilter)(nil).MayContain), ctx, key)
}

// RecordFalsePositive mocks base method.
func (m *MockFilter) RecordFalsePositive() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RecordFalsePositive")
}

// RecordFalsePositive indicates an expected call of RecordFalsePositive.
func (mr *MockFilterMockRecorder) RecordFalsePositive() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RecordFalsePositive", reflect.TypeOf((*MockFilter)(nil).RecordFalsePositive))
}

// Save mocks base method.
func (m *MockFilter) Save(ctx context.Context, store bond.FilterStorer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Save", ctx, store)
	ret0, _ := ret[0].(error)
	return ret0
}

// Save indicates an expected call of Save.
func (mr *MockFilterMockRecorder) Save(ctx, store any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockFilter)(nil).Save), ctx, store)
}

// Stats mocks base method.
func (m *MockFilter) Stats() bond.FilterStats {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stats")
	ret0, _ := ret[0].(bond.FilterStats)
	return ret0
}

// Stats indicates an expected call of Stats.
func (mr *MockFilterMockRecorder) Stats() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stats", reflect.TypeOf((*MockFilter)(nil).Stats))
}

// MockFilterStorer is a mock of FilterStorer interface.
type MockFilterStorer struct {
	ctrl     *gomock.Controller
	recorder *MockFilterStorerMockRecorder
	isgomock struct{}
}

// MockFilterStorerMockRecorder is the mock recorder for MockFilterStorer.
type MockFilterStorerMockRecorder struct {
	mock *MockFilterStorer
}

// NewMockFilterStorer creates a new mock instance.
func NewMockFilterStorer(ctrl *gomock.Controller) *MockFilterStorer {
	mock := &MockFilterStorer{ctrl: ctrl}
	mock.recorder = &MockFilterStorerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFilterStorer) EXPECT() *MockFilterStorerMockRecorder {
	return m.recorder
}

// DeleteRange mocks base method.
func (m *MockFilterStorer) DeleteRange(start, end []byte, opt bond.WriteOptions, batch ...bond.Batch) error {
	m.ctrl.T.Helper()
	varargs := []any{start, end, opt}
	for _, a := range batch {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteRange", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteRange indicates an expected call of DeleteRange.
func (mr *MockFilterStorerMockRecorder) DeleteRange(start, end, opt any, batch ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{start, end, opt}, batch...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRange", reflect.TypeOf((*MockFilterStorer)(nil).DeleteRange), varargs...)
}

// Get mocks base method.
func (m *MockFilterStorer) Get(key []byte, batch ...bond.Batch) ([]byte, io.Closer, error) {
	m.ctrl.T.Helper()
	varargs := []any{key}
	for _, a := range batch {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Get", varargs...)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(io.Closer)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Get indicates an expected call of Get.
func (mr *MockFilterStorerMockRecorder) Get(key any, batch ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{key}, batch...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockFilterStorer)(nil).Get), varargs...)
}

// Set mocks base method.
func (m *MockFilterStorer) Set(key, value []byte, opt bond.WriteOptions, batch ...bond.Batch) error {
	m.ctrl.T.Helper()
	varargs := []any{key, value, opt}
	for _, a := range batch {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Set", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockFilterStorerMockRecorder) Set(key, value, opt any, batch ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{key, value, opt}, batch...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockFilterStorer)(nil).Set), varargs...)
}

// MockTableScanner is a mock of TableScanner interface.
type MockTableScanner[T any] struct {
	ctrl     *gomock.Controller
	recorder *MockTableScannerMockRecorder[T]
	isgomock struct{}
}

// MockTableScannerMockRecorder is the mock recorder for MockTableScanner.
type MockTableScannerMockRecorder[T any] struct {
	mock *MockTableScanner[T]
}

// NewMockTableScanner creates a new mock instance.
func NewMockTableScanner[T any](ctrl *gomock.Controller) *MockTableScanner[T] {
	mock := &MockTableScanner[T]{ctrl: ctrl}
	mock.recorder = &MockTableScannerMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTableScanner[T]) EXPECT() *MockTableScannerMockRecorder[T] {
	return m.recorder
}

// Scan mocks base method.
func (m *MockTableScanner[T]) Scan(ctx context.Context, tr *[]T, reverse bool, optBatch ...bond.Batch) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, tr, reverse}
	for _, a := range optBatch {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan.
func (mr *MockTableScannerMockRecorder[T]) Scan(ctx, tr, reverse any, optBatch ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, tr, reverse}, optBatch...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockTableScanner[T])(nil).Scan), varargs...)
}

// ScanForEach mocks base method.
func (m *MockTableScanner[T]) ScanForEach(ctx context.Context, f func(bond.KeyBytes, bond.Lazy[T]) (bool, error), reverse bool, optBatch ...bond.Batch) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, f, reverse}
	for _, a := range optBatch {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ScanForEach", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ScanForEach indicates an expected call of ScanForEach.
func (mr *MockTableScannerMockRecorder[T]) ScanForEach(ctx, f, reverse any, optBatch ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, f, reverse}, optBatch...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanForEach", reflect.TypeOf((*MockTableScanner[T])(nil).ScanForEach), varargs...)
}

// ScanIndex mocks base method.
func (m *MockTableScanner[T]) ScanIndex(ctx context.Context, i *bond.Index[T], s bond.Selector[T], tr *[]T, reverse bool, optBatch ...bond.Batch) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, i, s, tr, reverse}
	for _, a := range optBatch {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ScanIndex", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ScanIndex indicates an expected call of ScanIndex.
func (mr *MockTableScannerMockRecorder[T]) ScanIndex(ctx, i, s, tr, reverse any, optBatch ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, i, s, tr, reverse}, optBatch...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanIndex", reflect.TypeOf((*MockTableScanner[T])(nil).ScanIndex), varargs...)
}

// ScanIndexForEach mocks base method.
func (m *MockTableScanner[T]) ScanIndexForEach(ctx context.Context, idx *bond.Index[T], s bond.Selector[T], f func(bond.KeyBytes, bond.Lazy[T]) (bool, error), reverse bool, optBatch ...bond.Batch) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx, idx, s, f, reverse}
	for _, a := range optBatch {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ScanIndexForEach", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ScanIndexForEach indicates an expected call of ScanIndexForEach.
func (mr *MockTableScannerMockRecorder[T]) ScanIndexForEach(ctx, idx, s, f, reverse any, optBatch ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, idx, s, f, reverse}, optBatch...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScanIndexForEach", reflect.TypeOf((*MockTableScanner[T])(nil).ScanIndexForEach), varargs...)
}

// MockBatch is a mock of Batch interface.
type MockBatch struct {
	ctrl     *gomock.Controller
	recorder *MockBatchMockRecorder
	isgomock struct{}
}

// MockBatchMockRecorder is the mock recorder for MockBatch.
type MockBatchMockRecorder struct {
	mock *MockBatch
}

// NewMockBatch creates a new mock instance.
func NewMockBatch(ctrl *gomock.Controller) *MockBatch {
	mock := &MockBatch{ctrl: ctrl}
	mock.recorder = &MockBatchMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBatch) EXPECT() *MockBatchMockRecorder {
	return m.recorder
}

// Apply mocks base method.
func (m *MockBatch) Apply(b bond.Batch, opt bond.WriteOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Apply", b, opt)
	ret0, _ := ret[0].(error)
	return ret0
}

// Apply indicates an expected call of Apply.
func (mr *MockBatchMockRecorder) Apply(b, opt any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockBatch)(nil).Apply), b, opt)
}

// Close mocks base method.
func (m *MockBatch) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockBatchMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockBatch)(nil).Close))
}

// Commit mocks base method.
func (m *MockBatch) Commit(opt bond.WriteOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", opt)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockBatchMockRecorder) Commit(opt any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockBatch)(nil).Commit), opt)
}

// Count mocks base method.
func (m *MockBatch) Count() uint32 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count")
	ret0, _ := ret[0].(uint32)
	return ret0
}

// Count indicates an expected call of Count.
func (mr *MockBatchMockRecorder) Count() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockBatch)(nil).Count))
}

// Delete mocks base method.
func (m *MockBatch) Delete(key []byte, opt bond.WriteOptions, batch ...bond.Batch) error {
	m.ctrl.T.Helper()
	varargs := []any{key, opt}
	for _, a := range batch {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Delete", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockBatchMockRecorder) Delete(key, opt any, batch ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{key, opt}, batch...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockBatch)(nil).Delete), varargs...)
}

// DeleteRange mocks base method.
func (m *MockBatch) DeleteRange(start, end []byte, opt bond.WriteOptions, batch ...bond.Batch) error {
	m.ctrl.T.Helper()
	varargs := []any{start, end, opt}
	for _, a := range batch {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteRange", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteRange indicates an expected call of DeleteRange.
func (mr *MockBatchMockRecorder) DeleteRange(start, end, opt any, batch ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{start, end, opt}, batch...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteRange", reflect.TypeOf((*MockBatch)(nil).DeleteRange), varargs...)
}

// Empty mocks base method.
func (m *MockBatch) Empty() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Empty")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Empty indicates an expected call of Empty.
func (mr *MockBatchMockRecorder) Empty() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Empty", reflect.TypeOf((*MockBatch)(nil).Empty))
}

// Get mocks base method.
func (m *MockBatch) Get(key []byte, batch ...bond.Batch) ([]byte, io.Closer, error) {
	m.ctrl.T.Helper()
	varargs := []any{key}
	for _, a := range batch {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Get", varargs...)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(io.Closer)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Get indicates an expected call of Get.
func (mr *MockBatchMockRecorder) Get(key any, batch ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{key}, batch...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockBatch)(nil).Get), varargs...)
}

// ID mocks base method.
func (m *MockBatch) ID() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockBatchMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockBatch)(nil).ID))
}

// Iter mocks base method.
func (m *MockBatch) Iter(opt *bond.IterOptions, batch ...bond.Batch) bond.Iterator {
	m.ctrl.T.Helper()
	varargs := []any{opt}
	for _, a := range batch {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Iter", varargs...)
	ret0, _ := ret[0].(bond.Iterator)
	return ret0
}

// Iter indicates an expected call of Iter.
func (mr *MockBatchMockRecorder) Iter(opt any, batch ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{opt}, batch...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Iter", reflect.TypeOf((*MockBatch)(nil).Iter), varargs...)
}

// Len mocks base method.
func (m *MockBatch) Len() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Len")
	ret0, _ := ret[0].(int)
	return ret0
}

// Len indicates an expected call of Len.
func (mr *MockBatchMockRecorder) Len() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Len", reflect.TypeOf((*MockBatch)(nil).Len))
}

// OnClose mocks base method.
func (m *MockBatch) OnClose(arg0 func(bond.Batch)) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "OnClose", arg0)
}

// OnClose indicates an expected call of OnClose.
func (mr *MockBatchMockRecorder) OnClose(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnClose", reflect.TypeOf((*MockBatch)(nil).OnClose), arg0)
}

// OnCommit mocks base method.
func (m *MockBatch) OnCommit(arg0 func(bond.Batch) error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "OnCommit", arg0)
}

// OnCommit indicates an expected call of OnCommit.
func (mr *MockBatchMockRecorder) OnCommit(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnCommit", reflect.TypeOf((*MockBatch)(nil).OnCommit), arg0)
}

// OnCommitted mocks base method.
func (m *MockBatch) OnCommitted(arg0 func(bond.Batch)) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "OnCommitted", arg0)
}

// OnCommitted indicates an expected call of OnCommitted.
func (mr *MockBatchMockRecorder) OnCommitted(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnCommitted", reflect.TypeOf((*MockBatch)(nil).OnCommitted), arg0)
}

// OnError mocks base method.
func (m *MockBatch) OnError(arg0 func(bond.Batch, error)) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "OnError", arg0)
}

// OnError indicates an expected call of OnError.
func (mr *MockBatchMockRecorder) OnError(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnError", reflect.TypeOf((*MockBatch)(nil).OnError), arg0)
}

// Reset mocks base method.
func (m *MockBatch) Reset() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Reset")
}

// Reset indicates an expected call of Reset.
func (mr *MockBatchMockRecorder) Reset() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reset", reflect.TypeOf((*MockBatch)(nil).Reset))
}

// Set mocks base method.
func (m *MockBatch) Set(key, value []byte, opt bond.WriteOptions, batch ...bond.Batch) error {
	m.ctrl.T.Helper()
	varargs := []any{key, value, opt}
	for _, a := range batch {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Set", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockBatchMockRecorder) Set(key, value, opt any, batch ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{key, value, opt}, batch...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockBatch)(nil).Set), varargs...)
}

// Type mocks base method.
func (m *MockBatch) Type() bond.BatchType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Type")
	ret0, _ := ret[0].(bond.BatchType)
	return ret0
}

// Type indicates an expected call of Type.
func (mr *MockBatchMockRecorder) Type() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Type", reflect.TypeOf((*MockBatch)(nil).Type))
}
